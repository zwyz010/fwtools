/******************************************
 * D-Link Firmware unpacker V1.0          *
 * DCS-2130, DCS-2230, DCS-6815, DCS-3710 *
 * DCS-3716, DCS-6511, DCS-6818, DVS-210  *
 * DCS-6616, DVS-310                      *
 *                                        *
 * Version 1.00                09/2012    *
 * http://www.hardwarefetish.com          *
 ******************************************/

#include <stdio.h>

#define HEADER_MAGIC 0xAA7EC55B

#define SECT_SIGN	0xA55A
#define SECTT_AUTO	0
#define SECTT_JFFS2	1
#define SECTT_YAFFS	2
#define SECTT_NONE	3

#pragma pack(1)
typedef struct
{
	unsigned short hdr;	// A55A
	char mtd;
	char section_type;
	unsigned long size;
	unsigned long offset;	// # of 0x4000 chunks?
	char padding[52];
} sec_head;

static char *sectypes[] = {
	"AUTO ",
	"JFFS2",
	"YAFFS",
	"NONE "
};

typedef struct {
	int Signature;
	int size;
	unsigned short checksum;
	unsigned short scramble;
	unsigned short hdrBlocks;	// ?? Don't really know that this is
	unsigned short machine_code;
} fm_header;
#pragma pack()

fm_header FmHead;
unsigned short scramble = 0x2021;
unsigned short machine_code = 0x2021;

unsigned short random1[] =
{
0x07CC, 0x33A8, 0xAEA8, 0x5A00, 0xDD42, 0x518E, 0x45B2, 0x0DED, 
0x6D05, 0xD447, 0x9C3F, 0x4678, 0xB113, 0x7BF8, 0x4510, 0xB3F8,
0x9C21, 0xFD90, 0x8055, 0xB43A, 0xCE09, 0x5294, 0x6100, 0xD7DC, 
0x989A, 0x4EC7, 0xC3D3, 0xFF7E, 0xEF08, 0xA4DA, 0xD9D3, 0xF6D4,
0xD883, 0x887B, 0x50D4, 0xB5C5, 0xDA09, 0x9687, 0xC3B3, 0x470F,
0x6ACE, 0x5FF2, 0x8D87, 0x1BE1, 0xDBEA, 0xD297, 0xCFDA, 0x780B,
0xD027, 0x502F, 0x2C45, 0x9E31, 0xA2C3, 0x8D45, 0x760D, 0x3B5D, 
0xDC0D, 0x39E1, 0x3ADB, 0xCB15, 0xDEBB, 0x14AE, 0xC1E9, 0xB73E,
0x9D2A, 0x12BD, 0x6D04, 0x7733, 0xA944, 0x30B7, 0xBE42, 0x1413, 
0x90A9, 0x4BC9, 0x2FF4, 0x6C93, 0x1E60, 0xFFCE, 0xE49E, 0xEE88,
0x4FFE, 0x10E4, 0x8CB9, 0xF2C1, 0x9E29, 0x02C6, 0x2E1F, 0x7A36, 
0x3CA7, 0x68FA, 0x454B, 0x1B63, 0x7DA9, 0x0734, 0xD2A1, 0x1AD3,
0x19F2, 0x3FA5, 0x9206, 0xC336, 0x705C, 0x5049, 0xD749, 0x0105,
0x9C12, 0x073E, 0x6D98, 0xBA73, 0x070C, 0x5237, 0xA8FB, 0x570A,
0x631B, 0x35B4, 0x49CC, 0x0144, 0x387A, 0x77EB, 0x7B7B, 0x7522, 
0xE0E5, 0xC0C6, 0x9085, 0x5E8E, 0xC7FB, 0x6326, 0x7961, 0xE1ED,
0xA2CC, 0x0B68, 0xA523, 0x1328, 0x5BB1, 0x7C6D, 0x142E, 0xF7C3, 
0x83AB, 0x81C6, 0xB236, 0x8AB7, 0xD3FD, 0x5B31, 0xE1C2, 0x3718,
0x90E5, 0x2B8E, 0x385D, 0xC960, 0xA379, 0xB3D8, 0x3E82, 0x845E,
0x749E, 0xCF07, 0xE2ED, 0x3C99, 0x322D, 0x5C4E, 0x1E86, 0xD4F9,
0x67B6, 0xC3AA, 0xE822, 0xC367, 0x4017, 0xFC50, 0xBB2B, 0xC3C2,
0x7E16, 0x6D61, 0x4E79, 0x5214, 0xC893, 0x303B, 0x892C, 0x5978,
0x5BC9, 0xC189, 0x22D8, 0xFF42, 0x7561, 0x615A, 0x83A1, 0xEA00,
0x3061, 0x668E, 0x2699, 0x628F, 0xC2DC, 0x4520, 0x3788, 0x2A93,
0x08CA, 0x1FAA, 0xEDFA, 0x48E1, 0x1BFA, 0xA925, 0x0CA3
};

unsigned short random2[] =
{
0x9A11, 0x1687, 0x5B1C, 0xEC25, 0xDF1A, 0x8B58, 0x7551, 0x3892,
0xE721, 0x36DB, 0x5B6B, 0xE664, 0xAC3C, 0xBCC5, 0x6A05, 0x963C,
0xED27, 0xD093, 0xBCD6, 0x4FB6, 0x936F, 0x01F6, 0x873E, 0xBE02,
0x0AC0, 0xA6E9, 0xABFD, 0x53A1, 0xC2E3, 0x5522, 0x6044, 0x5CF4, 
0x6BA9, 0xBB60, 0x4919, 0x4AC3, 0x46B8, 0xBE6B, 0x8356, 0x2DDA,
0xF546, 0xDEC1, 0x143E, 0xA182, 0x9B86, 0x7E43, 0x37BF, 0x88AD, 
0x4ED6, 0xF495, 0xD863, 0xE245, 0xF68B, 0x5FA2, 0xA048, 0x014B,
0x068B, 0x4C45, 0x54EC, 0xC96E, 0xA167, 0xB530, 0x2663, 0x0D11,
0x7090, 0x6F7C, 0x57D4, 0xB749, 0x2DE7, 0xDB2A, 0xE523, 0x232D,
0xB9EB, 0xF961, 0xC4B0, 0x5572, 0x77A4, 0xFC6F, 0xDE1F, 0xC67A,
0xF104, 0xB683, 0xA8BF, 0xE78F, 0x1625, 0x4907, 0xE8DA, 0x1CB0,
0x954C, 0x3DC6, 0xE61E, 0x36B4, 0xF2F6, 0x0C81, 0x43C5, 0x6386, 
0x7BFE, 0x9B99, 0x1ACF, 0xA9E5, 0x76C4, 0xFFF2, 0xCD13, 0x30AF,
0xF953, 0x91C3, 0x8621, 0x70F7, 0x8E32, 0x6441, 0x3771, 0x7F36, 
0x1AC4, 0xE031, 0x66C5, 0x30E9, 0x2938, 0x4F9F, 0x4D99, 0xBE85,
0x8D65, 0x33B7, 0xF539, 0x805B, 0x4039, 0x38FE, 0xE3E1, 0xBC37, 
0xD497, 0xFEB1, 0x661C, 0x4B5B, 0xFEA3, 0x332F, 0x7C0B, 0xF7F7,
0xC4F2, 0x022C, 0x68EE, 0x5324, 0x666D, 0xA060, 0xD25A, 0x8131, 
0x8091, 0x391F, 0xB21A, 0xA9C9, 0x88BE, 0xFFB3, 0x684E, 0x1623,
0x336B, 0x5D87, 0x967E, 0x73A4, 0x9685, 0x7A60, 0x2FDB, 0x6B1D, 
0x7911, 0x95F7, 0xB678, 0x77B4, 0xC927, 0x3283, 0x6FAB, 0x8E19,
0x34B0, 0xD89A, 0xE13E, 0x9B1D, 0x78FA, 0xB398, 0x1C4F, 0xF98B, 
0xECB8, 0xCE69, 0xA354, 0x7576, 0xCE1D, 0x0BA3, 0x8B9A, 0x0188,
0x692A, 0x2218, 0x752C, 0xFFB0, 0x9C78, 0xA507, 0x6ACD, 0x1589, 
0x3AFE, 0x2145, 0x8D3E, 0x0425, 0x53C9, 0xFCE9, 0x923F, 0x8879,
0xD583, 0x737D, 0x2396, 0x4E7D, 0x2715, 0x3FE5, 0x4808, 0x13CD, 
0x0E4F, 0xEB5D, 0x8944
};

unsigned short random3[] =
{
0xDC6C, 0xF700, 0x14DE, 0xDDF4, 0x602A, 0x36F6, 0x5320, 0x5FDA, 
0xD36F, 0xF827, 0xCAA7, 0xE8F8, 0x3325, 0xEBED, 0x7636, 0x374B,
0x3FB6, 0x7320, 0xC98A, 0xC82F, 0x48A3, 0x3D07, 0xEBC5, 0x9721,
0x641C, 0x2BAB, 0xDF29, 0x77EA, 0x39FA, 0xCA86, 0x012E, 0x1666,
0xC186, 0x160C, 0xF45A, 0x21B1, 0x4D02, 0x477A, 0x818B, 0x2071,
0x3FA1, 0x4C33, 0x096A, 0x72C6, 0x3820, 0x7FA0, 0xAA11, 0x77D6,
0xF2C0, 0x739B, 0x4005, 0x3B64, 0xB0A2, 0x2BCA, 0xD285, 0x14BF,
0x5775, 0xB1AE, 0x8CA9, 0x916F, 0x7C35, 0x8DD7, 0xA7D5, 0x3DBB,
0xA3E3, 0x9C2F, 0x5F6C, 0xF0E5, 0xE3A9, 0xE0F8, 0x1157, 0x234A,
0x2D2B, 0x1AC1, 0x9611, 0x654B, 0x9A61, 0x4022, 0xDD21, 0x8D22,
0xB3BE, 0x1D26, 0xC886, 0x6460, 0x48F0, 0x9B0B, 0x791F, 0xA066,
0x4CB9, 0x05C8, 0x31D5, 0xC8EE, 0x939F, 0xD9AB, 0x06AA, 0x3782,
0x75DA, 0x6616, 0x2868, 0x5984, 0x470E, 0x39BF, 0x7CCE, 0x7439,
0x5480, 0x12DF, 0xD984, 0xEEE1, 0x5302, 0xB6A5, 0x7C03, 0x06C0,
0xD3CB, 0x4489, 0x6B20, 0x1CBC, 0xDF94, 0xE440, 0xBD22, 0x2C4E,
0xEA08, 0xEEF7, 0xF53C, 0x7DA8, 0xC8A2, 0xFBE6, 0xB52A, 0x3E7D,
0x61FD, 0xDD92, 0x9801, 0xA90B, 0x1751, 0x14CF, 0x1D45, 0x6BD1,
0x27AF, 0xF6C9, 0x5AB3, 0x7AB1, 0xAD6F, 0xD6B6, 0x8171, 0x813A,
0x1B40, 0xEC91, 0x9DF6, 0xFAD4, 0xD0D1, 0x5B18, 0x2722, 0xBADA,
0x4A10, 0x1C5F, 0x3882, 0x12B2, 0x1845, 0xEDAC, 0x512F, 0x7A42,
0xCB3F, 0xE930, 0x234E, 0xE290, 0xFE00, 0x4093, 0x4E62, 0x25AF,
0x375C, 0xA915, 0xA060, 0xE4CB, 0x7FCB, 0x21D1, 0x6606, 0x9B0B,
0x0E62, 0x03FC, 0x95E0, 0xDF34, 0x5F15, 0xBD02, 0x9A0E, 0xA925,
0xD961, 0xD290, 0xBBD7, 0xF1A7, 0xC03C, 0x0D07, 0x6BE9, 0x8B7B,
0xF637, 0x8F37, 0x6E0C, 0xF437, 0xCFCA, 0xBC6E, 0x19E6, 0x0727,
0x6583, 0xBA46, 0xEBF2, 0xE54E, 0xDC17, 0x51F8, 0x805A, 0xEA7A,
0x55F5, 0x163A, 0xC9AE, 0xB50A, 0xD33C, 0x63BC, 0x5E2F, 0xAC9E,
0x364C, 0x1A06, 0x9E45, 0xF688, 0x270D, 0x0A2E, 0x8204
};

static unsigned short get_rand1()
{
	static short cnt = 0;
	unsigned short result = random1[cnt];

	cnt = (cnt+1)%(sizeof(random1)/sizeof(random1[0]));
	return result;
}

static unsigned short get_rand2()
{
	static short cnt = 0;
	unsigned short result = random2[cnt];

	cnt = (cnt+1)%(sizeof(random2)/sizeof(random2[0]));
	return result;
}

static unsigned short get_rand3()
{
	static short cnt = 0;
	unsigned short result = random3[cnt];

	cnt = (cnt+1)%(sizeof(random3)/sizeof(random3[0]));
	return result;
}

static unsigned short get_random()
{
	return get_rand3() ^ (get_rand1() ^get_rand2());
}

static void decode_data(short *dest, short *src, int nBytes)
{
	while (nBytes)
	{
		*dest = get_random() ^ scramble ^ *src ^ machine_code;
		src++;
		dest++;
		nBytes -= sizeof(short);
	}
}

static void decode_header(short *dest, short *src, int nBytes)
{
	while (nBytes)
	{
		*dest = *src ^ machine_code;
		src++;
		dest++;
		nBytes -= sizeof(short);
	}
}

static int get_num_sections(FILE *fp)
{
	sec_head SectHead;
	int sects = 0;

	fseek(fp, 0x10, SEEK_SET);
	while (fread(&SectHead, sizeof(SectHead), 1, fp) && SectHead.hdr == SECT_SIGN)
		sects++;
	return sects;
}

static void dump_sections(FILE *fp)
{
	sec_head SectHead;
	int i, offset, sects;
	FILE *fpOut;
	char szFile[16];

	if (!(sects = get_num_sections(fp)))
	{
		fprintf (stderr, "Cannot determine number of sections.\n");
		return;
	}
	offset=0x10+sects*sizeof(SectHead);
	for (i=0; i<sects; i++)
	{
		fseek(fp, 0x10+i*sizeof(SectHead), SEEK_SET);
		if (!fread(&SectHead, sizeof(SectHead), 1, fp))
		{
			fprintf (stderr, "Cannot read header block %d\n", i);
			return;
		}
		if (SectHead.hdr != SECT_SIGN)
		{
			fprintf (stderr, "Header block %d has invalid signature: %04X\n", i, SectHead.hdr);
			return;
		}
		printf ("Section %-2d:  mtd: %-3d Type: %s Size: %-10ld Offset: %-8lX  @%08X\n", 
			i, SectHead.mtd, sectypes[SectHead.section_type], SectHead.size, SectHead.offset * 0x4000, offset);
		fseek(fp, offset, SEEK_SET);
		sprintf (szFile, "%08X.dmp", i);
		if (fpOut = fopen(szFile, "wb"))
		{
			int size, read=0;
			unsigned char buf[1024];

			for (size=SectHead.size; size>0; size-=read)
			{
				read = fread(buf, 1, size>sizeof(buf)?sizeof(buf):size, fp);
				if (!read) break;
				fwrite (buf, 1, read, fpOut);
			}
			printf ("Dumped to %s.\n", szFile);
			fclose(fpOut);
		}
		offset += SectHead.size;
	}
}

static void usage(char *pszApp)
{
	fprintf (stderr, "%s <firmware file> <output file>\n", pszApp);
}

int main(int argc, char **argv)
{
	FILE *fp, *fpDst;
	int iRet = -1;

	printf ("D-Link firmware decrypter V1.00\nhttp://www.hardwarefetish.com\n\n");
	if (argc<3)
	{
		usage(argv[0]);
		return -1;
	}

	if (!(fp = fopen(argv[1], "rb")))
	{
		perror("Cannot open input file");
		return -1;
	}

	if (!(fpDst = fopen(argv[2], "w+b")))
	{
		fclose (fp);
		perror("Cannot open output file");
		return -1;
	}

	if (fread(&FmHead, sizeof(FmHead), 1, fp))
	{
		int size, read=0;
		unsigned char buf[1024];

		if (FmHead.machine_code) machine_code = FmHead.machine_code;
		decode_header((short*)&FmHead, (short*)&FmHead, sizeof(FmHead));
		scramble = FmHead.scramble;
		fwrite(&FmHead, sizeof(FmHead), 1, fpDst);
		printf ("magic = %08X, machine_code = %04X, scramble = %04X, checksum = %04X\n", 
			FmHead.Signature, machine_code, scramble, FmHead.checksum);

		while (read = fread(buf, 1, sizeof(buf), fp))
		{
			decode_data((short*)buf, (short*)buf, read);
			fwrite (buf, 1, read, fpDst);
		}
		printf ("%s written.\n", argv[2]);
		dump_sections(fpDst);
		iRet = 0;
	}
	else perror("Reading header failed.");
	fclose (fp);
	fclose (fpDst);
	return iRet;
}
